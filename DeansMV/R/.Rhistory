set.seed(1)
p <- length(means)
# Construct correlation matrix
cor_matrix <- diag(p)
cor_matrix[lower.tri(cor_matrix)] <- within_cor
cor_matrix[upper.tri(cor_matrix)] <- t(cor_matrix)[upper.tri(cor_matrix)]
cor_matrix[1:column, (column + 1):p] <- between_cor
cor_matrix[(column + 1):p, 1:column] <- between_cor
cor_matrix <- nearPD(cor_matrix)$mat  # Ensure positive definite
# Generate correlated data
multivariate_data <- MASS::mvrnorm(n = n, mu = means, Sigma = cor_matrix, empirical = TRUE)
# Split the data
MV1 <- multivariate_data[, 1:column]
MV2 <- multivariate_data[, (column + 1):ncol(multivariate_data)]
# Return the split data
return(list(MV1 = MV1, MV2 = MV2))
}
}
library(MASS)
library(Matrix)
simulate_multivariate_data <- function(n, means, diag_cor, within_cor, between_cor,column) {
set.seed(1)
p <- length(means)
# Construct correlation matrix
cor_matrix <- diag(p)
cor_matrix[lower.tri(cor_matrix)] <- within_cor
cor_matrix[upper.tri(cor_matrix)] <- t(cor_matrix)[upper.tri(cor_matrix)]
cor_matrix[1:column, (column + 1):p] <- between_cor
cor_matrix[(column + 1):p, 1:column] <- between_cor
cor_matrix <- nearPD(cor_matrix)$mat  # Ensure positive definite
# Generate correlated data
multivariate_data <- MASS::mvrnorm(n = n, mu = means, Sigma = cor_matrix, empirical = TRUE)
# Split the data
MV1 <- multivariate_data[, 1:column]
MV2 <- multivariate_data[, (column + 1):ncol(multivariate_data)]
# Return the split data
return(list(MV1 = MV1, MV2 = MV2))
}
# Constant parameters
n <- 3000
means <- rep(0, 20)
diag_cor  <- 1
within_cor <- 0.1
between_cor <- 0.2
column <- 7
# Call the function
my_data <- simulate_multivariate_data(n, means, diag_cor, within_cor, between_cor, column)
# Access the split data
MV1 <- my_data$MV1
MV2 <- my_data$MV2
cor(MV1)
cor(MV2)
library(MASS)
library(Matrix)
simulate_multivariate_data <- function(n, means, diag_cor, within_cor, between_cor,column) {
set.seed(1)
p <- length(means)
# Construct correlation matrix
cor_matrix <- diag(p)
cor_matrix[lower.tri(cor_matrix)] <- within_cor
cor_matrix[upper.tri(cor_matrix)] <- t(cor_matrix)[upper.tri(cor_matrix)]
cor_matrix[1:column, (column + 1):p] <- between_cor
cor_matrix[(column + 1):p, 1:column] <- between_cor
cor_matrix <- nearPD(cor_matrix)$mat  # Ensure positive definite
# Generate correlated data
multivariate_data <- MASS::mvrnorm(n = n, mu = means, Sigma = cor_matrix, empirical = TRUE)
# Split the data
MV1 <- multivariate_data[, 1:column]
MV2 <- multivariate_data[, (column + 1):ncol(multivariate_data)]
# Return the split data
return(list(MV1 = MV1, MV2 = MV2))
}
# Constant parameters
n <- 3000
means <- rep(0, 20)
diag_cor  <- 1
within_cor <- 0.1
between_cor <- 0.2
column <- 7
# Call the function
my_data <- simulate_multivariate_data(n, means, diag_cor, within_cor, between_cor, column)
# Access the split data
MV1 <- my_data$MV1
MV2 <- my_data$MV2
cor(MV1)
cor(MV2)
cor(MV1,MV2)
setwd("C:/Users/essoh/OneDrive/Desktop/Essoh-DeansMV/DeansMV/R")
# Define UI
ui <- fluidPage(
titlePanel("DeansMV Package: Multivariate Data Simulation and Analysis"),
sidebarLayout(
sidebarPanel(
tabsetPanel(
tabPanel("Data Simulation",
numericInput("n", "Number of samples:", 100),
textInput("means", "Means (comma separated):", "0,0,0,0"),
textInput("cor_values", "Correlation values (comma separated):", "0.5,0.5,0.5,0.5,0.5,0.5"),
actionButton("simulate", "Simulate Data")
),
tabPanel("Representational Similarity Analysis",
actionButton("rsa", "Compute Distance Matrix Correlation"),
actionButton("null_dist_rsa", "Generate Permuted Null Distribution"),
actionButton("adjust_rsa", "Adjust Correlation Estimate"),
actionButton("perm_test_rsa", "Compute P-value")
),
tabPanel("Canonical Correlation Analysis",
actionButton("max_cancor", "Compute Highest Canonical Correlation"),
actionButton("null_dist_cca", "Generate Permuted Null Distribution"),
actionButton("adjust_cca", "Adjust Correlation Estimate"),
actionButton("perm_test_cca", "Compute P-value")
)
)
),
mainPanel(
tabsetPanel(
tabPanel("Simulation Results", tableOutput("simulated_data")),
tabPanel("RSA Results",
tableOutput("rsa_results_table"),
plotOutput("rsa_plot")),
tabPanel("CCA Results",
tableOutput("cca_results_table"),
plotOutput("cca_plot"))
)
)
)
)
library(shiny)
library(DeansMV)
library(MASS)
library(Matrix)
# Define UI
ui <- fluidPage(
titlePanel("DeansMV Package: Multivariate Data Simulation and Analysis"),
sidebarLayout(
sidebarPanel(
tabsetPanel(
tabPanel("Data Simulation",
numericInput("n", "Number of samples:", 100),
textInput("means", "Means (comma separated):", "0,0,0,0"),
textInput("cor_values", "Correlation values (comma separated):", "0.5,0.5,0.5,0.5,0.5,0.5"),
actionButton("simulate", "Simulate Data")
),
tabPanel("Representational Similarity Analysis",
actionButton("rsa", "Compute Distance Matrix Correlation"),
actionButton("null_dist_rsa", "Generate Permuted Null Distribution"),
actionButton("adjust_rsa", "Adjust Correlation Estimate"),
actionButton("perm_test_rsa", "Compute P-value")
),
tabPanel("Canonical Correlation Analysis",
actionButton("max_cancor", "Compute Highest Canonical Correlation"),
actionButton("null_dist_cca", "Generate Permuted Null Distribution"),
actionButton("adjust_cca", "Adjust Correlation Estimate"),
actionButton("perm_test_cca", "Compute P-value")
)
)
),
mainPanel(
tabsetPanel(
tabPanel("Simulation Results", tableOutput("simulated_data")),
tabPanel("RSA Results",
tableOutput("rsa_results_table"),
plotOutput("rsa_plot")),
tabPanel("CCA Results",
tableOutput("cca_results_table"),
plotOutput("cca_plot"))
)
)
)
)
# Define server logic
server <- function(input, output) {
simulated_data <- reactiveVal(NULL)
# Data Simulation
observeEvent(input$simulate, {
means <- as.numeric(unlist(strsplit(input$means, ",")))
cor_values <- as.numeric(unlist(strsplit(input$cor_values, ",")))
data <- simulate_multivariate_data(input$n, means, cor_values)
simulated_data(data)
output$simulated_data <- renderTable(data)
})
split_data <- reactive({
data <- simulated_data()
if (is.null(data)) return(NULL)
p <- ncol(data)
half_p <- p %/% 2
list(X = data[, 1:half_p], Y = data[, (half_p + 1):p])
})
# RSA Functions
rsa_results <- reactiveVal(list())
rsa_plot <- reactiveVal(NULL)
observeEvent(input$rsa, {
data <- split_data()
if (is.null(data)) return(NULL)
result <- RSA(data$X, data$Y)
new_results <- rsa_results()
new_results$RSA <- c(new_results$RSA, result)
rsa_results(new_results)
})
observeEvent(input$null_dist_rsa, {
data <- split_data()
if (is.null(data)) return(NULL)
result <- null.dist_RSA(data$X, data$Y)
rsa_plot(result)
})
observeEvent(input$adjust_rsa, {
data <- split_data()
if (is.null(data)) return(NULL)
observed <- RSA(data$X, data$Y)
result <- adjust_RSA(data$X, data$Y, observed = observed)
new_results <- rsa_results()
new_results$adjusted_RSA <- c(new_results$adjusted_RSA, result)
rsa_results(new_results)
})
observeEvent(input$perm_test_rsa, {
data <- split_data()
if (is.null(data)) return(NULL)
observed <- RSA(data$X, data$Y)
result <- Perm_test_RSA(data$X, data$Y, observed = observed)
new_results <- rsa_results()
new_results$perm_test_RSA <- c(new_results$perm_test_RSA, result)
rsa_results(new_results)
})
output$rsa_results_table <- renderTable({
rsa_results_list <- rsa_results()
do.call(rbind, lapply(rsa_results_list, function(res) {
if (is.null(res)) return(data.frame(Result = NA))
data.frame(Result = res)
}))
})
output$rsa_plot <- renderPlot({
rsa_plot()
})
# CCA Functions
cca_results <- reactiveVal(list())
cca_plot <- reactiveVal(NULL)
observeEvent(input$max_cancor, {
data <- split_data()
if (is.null(data)) return(NULL)
result <- max_cancor(data$X, data$Y)
new_results <- cca_results()
new_results$max_cancor <- c(new_results$max_cancor, result)
cca_results(new_results)
})
observeEvent(input$null_dist_cca, {
data <- split_data()
if (is.null(data)) return(NULL)
result <- null_dist_CCA(data$X, data$Y)
cca_plot(result)
})
observeEvent(input$adjust_cca, {
data <- split_data()
if (is.null(data)) return(NULL)
observed <- max_cancor(data$X, data$Y)
result <- adjust_CCA(data$X, data$Y, raw_CCA = observed)
new_results <- cca_results()
new_results$adjusted_CCA <- c(new_results$adjusted_CCA, result)
cca_results(new_results)
})
observeEvent(input$perm_test_cca, {
data <- split_data()
if (is.null(data)) return(NULL)
observed <- max_cancor(data$X, data$Y)
result <- Perm_test_CCA(data$X, data$Y, observed = observed)
new_results <- cca_results()
new_results$perm_test_CCA <- c(new_results$perm_test_CCA, result)
cca_results(new_results)
})
output$cca_results_table <- renderTable({
cca_results_list <- cca_results()
do.call(rbind, lapply(cca_results_list, function(res) {
if (is.null(res)) return(data.frame(Result = NA))
data.frame(Result = res)
}))
})
output$cca_plot <- renderPlot({
cca_plot()
})
}
# Run the application
shinyApp(ui = ui, server = server)
library(shiny)
library(DeansMV)
library(MASS)
library(Matrix)
# Define UI
ui <- fluidPage(
titlePanel("DeansMV Package: Multivariate Data Simulation and Analysis"),
sidebarLayout(
sidebarPanel(
tabsetPanel(
tabPanel("Data Simulation",
numericInput("n", "Number of samples:", 100),
textInput("means", "Means (comma separated):", "0,0,0,0"),
textInput("cor_values", "Correlation values (comma separated):", "0.5,0.5,0.5,0.5,0.5,0.5"),
actionButton("simulate", "Simulate Data")
),
tabPanel("Representational Similarity Analysis",
actionButton("rsa", "Compute Distance Matrix Correlation"),
actionButton("null_dist_rsa", "Generate Permuted Null Distribution"),
actionButton("adjust_rsa", "Adjust Correlation Estimate"),
actionButton("perm_test_rsa", "Compute P-value")
),
tabPanel("Canonical Correlation Analysis",
actionButton("max_cancor", "Compute Highest Canonical Correlation"),
actionButton("null_dist_cca", "Generate Permuted Null Distribution"),
actionButton("adjust_cca", "Adjust Correlation Estimate"),
actionButton("perm_test_cca", "Compute P-value")
)
)
),
mainPanel(
tabsetPanel(
tabPanel("Simulation Results", tableOutput("simulated_data")),
tabPanel("RSA Results",
tableOutput("rsa_results_table"),
plotOutput("rsa_plot")),
tabPanel("CCA Results",
tableOutput("cca_results_table"),
plotOutput("cca_plot"))
)
)
)
)
# Define server logic
server <- function(input, output) {
simulated_data <- reactiveVal(NULL)
# Data Simulation
observeEvent(input$simulate, {
means <- as.numeric(unlist(strsplit(input$means, ",")))
cor_values <- as.numeric(unlist(strsplit(input$cor_values, ",")))
data <- simulate_multivariate_data(input$n, means, cor_values)
simulated_data(data)
output$simulated_data <- renderTable(data)
})
split_data <- reactive({
data <- simulated_data()
if (is.null(data)) return(NULL)
p <- ncol(data)
half_p <- p %/% 2
list(X = data[, 1:half_p], Y = data[, (half_p + 1):p])
})
# RSA Functions
rsa_results <- reactiveVal(list())
rsa_plot <- reactiveVal(NULL)
observeEvent(input$rsa, {
data <- split_data()
if (is.null(data)) return(NULL)
result <- RSA(data$X, data$Y)
new_results <- rsa_results()
new_results$RSA <- c(new_results$RSA, result)
rsa_results(new_results)
})
observeEvent(input$null_dist_rsa, {
data <- split_data()
if (is.null(data)) return(NULL)
result <- null.dist_RSA(data$X, data$Y)
rsa_plot(result)
})
observeEvent(input$adjust_rsa, {
data <- split_data()
if (is.null(data)) return(NULL)
observed <- RSA(data$X, data$Y)
result <- adjust_RSA(data$X, data$Y, observed = observed)
new_results <- rsa_results()
new_results$adjusted_RSA <- c(new_results$adjusted_RSA, result)
rsa_results(new_results)
})
observeEvent(input$perm_test_rsa, {
data <- split_data()
if (is.null(data)) return(NULL)
observed <- RSA(data$X, data$Y)
result <- Perm_test_RSA(data$X, data$Y, observed = observed)
new_results <- rsa_results()
new_results$perm_test_RSA <- c(new_results$perm_test_RSA, result)
rsa_results(new_results)
})
output$rsa_results_table <- renderTable({
rsa_results_list <- rsa_results()
do.call(rbind, lapply(rsa_results_list, function(res) {
if (is.null(res)) return(data.frame(Result = NA))
data.frame(Result = res)
}))
})
output$rsa_plot <- renderPlot({
rsa_plot()
})
# CCA Functions
cca_results <- reactiveVal(list())
cca_plot <- reactiveVal(NULL)
observeEvent(input$max_cancor, {
data <- split_data()
if (is.null(data)) return(NULL)
result <- max_cancor(data$X, data$Y)
new_results <- cca_results()
new_results$max_cancor <- c(new_results$max_cancor, result)
cca_results(new_results)
})
observeEvent(input$null_dist_cca, {
data <- split_data()
if (is.null(data)) return(NULL)
result <- null_dist_CCA(data$X, data$Y)
cca_plot(result)
})
observeEvent(input$adjust_cca, {
data <- split_data()
if (is.null(data)) return(NULL)
observed <- max_cancor(data$X, data$Y)
result <- adjust_CCA(data$X, data$Y, raw_CCA = observed)
new_results <- cca_results()
new_results$adjusted_CCA <- c(new_results$adjusted_CCA, result)
cca_results(new_results)
})
observeEvent(input$perm_test_cca, {
data <- split_data()
if (is.null(data)) return(NULL)
observed <- max_cancor(data$X, data$Y)
result <- Perm_test_CCA(data$X, data$Y, observed = observed)
new_results <- cca_results()
new_results$perm_test_CCA <- c(new_results$perm_test_CCA, result)
cca_results(new_results)
})
output$cca_results_table <- renderTable({
cca_results_list <- cca_results()
do.call(rbind, lapply(cca_results_list, function(res) {
if (is.null(res)) return(data.frame(Result = NA))
data.frame(Result = res)
}))
})
output$cca_plot <- renderPlot({
cca_plot()
})
}
# Run the application
shinyApp(ui = ui, server = server)
ui <- fluidPage(
titlePanel("Multivariate Analysis Toolbox"),
# Data Simulation Panel
tabsetPanel(
tabPanel("Data Simulation",
sidebarLayout(
sidebarPanel(
numericInput("n", "Sample Size (n):", value = 100),
numericInput("means", "Means (comma separated):", value = 0, width = 200),
numericInput("diag_cor", "Diagonal Correlation:", value = 1),
numericInput("within_cor", "Within Correlation:", value = 0.1),
numericInput("between_cor", "Between Correlation:", value = 0.2),
numericInput("column", "Column to Split Data:", value = 2),
actionButton("simulate_data", "Simulate Data")
),
mainPanel(
textOutput("simulation_output")
)
)
),
# RSA Panel
tabPanel("RSA Functions",
sidebarLayout(
sidebarPanel(
actionButton("run_rsa", "Run RSA")
),
mainPanel(
textOutput("rsa_output")
)
)
),
# CCA Panel
tabPanel("CCA Functions",
sidebarLayout(
sidebarPanel(
actionButton("run_cca", "Run CCA")
),
mainPanel(
textOutput("cca_output")
)
)
)
)
)
server <- function(input, output, session) {
# Data Simulation
observeEvent(input$simulate_data, {
my_data <- simulate_multivariate_data(input$n,
as.numeric(strsplit(input$means, ",")[[1]]),
input$diag_cor,
input$within_cor,
input$between_cor,
input$column)
output$simulation_output <- renderText({
paste("Data Simulation Completed. MV1:", dim(my_data$MV1), "MV2:", dim(my_data$MV2))
})
})
# RSA Functions
observeEvent(input$run_rsa, {
# Perform RSA here using my_data$MV1 and my_data$MV2 as X and Y
rsa_correlation <- RSA(my_data$MV1, my_data$MV2)
output$rsa_output <- renderText({
paste("RSA Correlation:", rsa_correlation)
})
})
# CCA Functions
observeEvent(input$run_cca, {
# Perform CCA here using my_data$MV1 and my_data$MV2 as X and Y
max_CC <- max_cancor(my_data$MV1, my_data$MV2)
output$cca_output <- renderText({
paste("Maximum Canonical Correlation:", max_CC)
})
})
}
shinyApp(ui, server)
devtools::document()
devtools::document()
